/*
在只允许从左向右，从上到下移动的情况下，从mxn的矩阵（0,0）点，到（m-1，n-1）点，有多少路径；
*/
/*
常用的解题步骤
第一步：确定子问题。 在这一步重点是分析那些变量是随着问题规模的变小而变小的， 那些变量与问题的规模无关。
第二步：确定状态：根据上面找到的子问题来给你分割的子问题限定状态
第三步：推到出状态转移方程：这里要注意你的状态转移方程是不是满足所有的条件， 注意不要遗漏。
第四步：确定边界条件：先根据题目的限制条件来确定题目中给出的边界条件是否能直接推导出， 如果不行也可以尝试从边界条件反推（举个例子：a(n)→a(2)有递推关系， 但是a(2)→a(1)不符合上述递推关系， 我们就可以考虑用a(1)来倒推出a(2)， 然后将递推的终点设置为a(2)）;
第五步：确定实现方式：这个依照个人习惯 就像是01背包的两层for循环的顺序
第六步：确定优化方法：很多时候你会发现走到这里步的时候你需要返回第1步重来。首先考虑降维问题（优化内存）， 优先队列、四边形不等式（优化时间）等等。
*/
/*
常用方法

以下是方法， 但是不要局限在这里， 方法是无限的

（1）模型匹配法：熟练记忆并且理解LIS、LCS、01背包、完全背包、区间模型、树状模型。基本就是将原模型加以变化后加以套用

（2）三要素法：
·······先确定阶段：如数塔问题， 先确定当前选的是第几层。
·······先确定状态：这是最常用的绝大多数的DP都是这么做的。
·······先确定决策：背包问题（选还是不选第i种物品）
（3）寻找规律法：从小的状态开始推， 耐心找规律。

（4）边界条件法： 一般边界时容易导出状态关系的地方
*/

class Solution {
    public int uniquePaths(int m, int n) {
        //典型的动态规划问题！！！
        int[][] mat = new int[m][n];
        for(int i = 0; i < n; i++)
        {
            mat[0][i] = 1;
        }
        for(int i = 0; i < m; i++)
        {
            mat[i][0] = 1;
        }
        
        for(int i = 1;i < m; i++ )   //每一行
        {
            for(int j = 1; j < n; j++ ) //行的每一列
            {
                mat[i][j] = mat[i-1][j] + mat[i][j-1];
            }
        }
        return mat[m-1][n-1];
    }
}
